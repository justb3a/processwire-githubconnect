<?php namespace ProcessWire;

/**
 * GithubConnect See README.md for usage instructions.  ProcessWire 3.x
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * @author Tabea David <info@justonestep.de>
 * @version 0.0.3
 * @copyright Copyright (c) 2017 justonestep.de, <info@justonestep.de>
 * @see https://github.com/justonestep/processwire-githubconnect
 * @see http://www.processwire.com
 */

/**
 * Class GithubConnect
 */
class GithubConnect extends WireData implements Module, ConfigurableModule {

  const API_AUTHORIZE = 'https://github.com/login/oauth/authorize';
  const API_ACCESS_TOKEN = 'https://github.com/login/oauth/access_token';
  const API_REPOS = 'https://api.github.com/repos/';
  const API_ORGS = 'https://api.github.com/orgs/%s/repos';
  const API_FILES = 'https://api.github.com/repos/%s/git/trees/master';
  const API_FILE = 'https://api.github.com/repos/%s/git/blobs/%s';


  /**
   * Retrieves module meta data
   * Implementation of the Module interface
   *
   * @return array
   * @see http://processwire.com/apigen/class-Module.html
   */
  public static function getModuleInfo() {
    return array(
      'title' => 'Github Connect',
      'summary' => 'ProcessWire module to connect a Github OAuth application. ',
      'version' => 003,
      'href' => 'https://github.com/justonestep/processwire-githubconnect',
      'singular' => true,
      'autoload' => true,
      'icon' => 'github'
    );
  }

  /**
   * Initialize the module - ready
   *
   * ProcessWire calls this when the module is loaded. For 'autoload' modules, this will be called
   * when ProcessWire's API is ready. As a result, this is a good place to attach hooks.
   *
   * @see http://processwire.com/apigen/class-Module.html
   */
  public function ready() {
    $this->addHookBefore('InputfieldSelect::render', $this, 'getSelectableRepositories');
    $this->addHookBefore('ProcessPageEdit::processInput', $this, 'autofillFields');
  }

  /**
   * Autofill Fields
   *
   * @param HookEvent $event
   */
  public function autofillFields(HookEvent $event) {
    $form = $event->arguments(0);
    $repository = $this->input->post->{$this->fieldSelect};
    $sha = $this->input->post->{$this->fieldSubSelect};
    $sublist = $form->get($this->fieldSubSelect);

    if ($repository) {
      if ($this->fieldTeaser && !$sublist) {
        $repoData = $this->callApi(self::API_REPOS . $repository);
        $this->input->post->{$this->fieldTeaser} = $repoData['description'];
      }

      $data = $this->callApi(self::API_REPOS . $repository . '/readme');
      $this->input->post->{$this->fieldPlain} = $repository;
      if (!$sublist) $this->input->post->{$this->fieldBody} = base64_decode($data['content']);
    } elseif ($sublist && $sha) {
      $repository = $form->get($this->fieldPlain)->value;

      $data = $this->callApi(sprintf(self::API_FILE, $repository, $sha));
      $this->input->post->{$this->fieldBody} = base64_decode($data['content']);
    }
  }

  /**
   * Get Selectable Repositories by Organization
   *
   * @param HookEvent $event
   */
  public function getSelectableRepositories(HookEvent $event) {
    $field = $event->object;

    switch ($field->name) {
      case $this->fieldSelect:
        $this->addRepositoriesAsOptions($field);
        break;
      case $this->fieldSubSelect:
        $this->addFilesAsOptions($field);
        break;
    }
  }

  private function addRepositoriesAsOptions($field) {
    $page = $this->pages->get($this->input->get->id);
    $data = $this->callApi(sprintf(self::API_ORGS, $this->organization));

    if ($data) {
      foreach ($data as $repo) $field->addOption($repo['full_name'], $repo['name']);
      $page->of(false);
      $page->save($this->fieldSelect);
      $page->of(true);
    }
  }

  private function addFilesAsOptions($field) {
    $page = $this->pages->get($this->input->get->id);
    $form = $field->get('parent');
    $repository = $form->get($this->fieldPlain)->value;

    if ($this->fieldSubSelect && $repository) {
      $data = $this->callApi(sprintf(self::API_FILES, $repository));
      foreach ($data['tree'] as $f) {
        if ($f['path'] === 'LICENSE') continue;
        $field->addOption($f['sha'], $f['path']);
      }

      $page->of(false);
      $page->save($this->fieldSubSelect);
      $page->of(true);
    }
  }

  /**
   * Call Api
   *
   * @param string $url
   * @return array
   */
  private function callApi($url) {
    $connection = new WireHttp;
    $connection->setHeader('User-Agent:', ucfirst($this->organization) . '-App');
    $connection->set('access_token', $this->accessToken);
    $data = $connection->getJSON($url, true);

    return $data;
  }

  /**
   * 1. Redirect users to request GitHub access
   * @see: https://developer.github.com/v3/oauth/
   * If the user accepts your request, GitHub redirects back to your site
   * with a temporary code in a code parameter as well as the state you provided.
   */
  public function authorize() {
    // an unguessable random string
    // it is used to protect against cross-site request forgery attacks
    $state = uniqid();

    $request = array(
      'client_id' => $this->clientId,
      'redirect_uri' => $this->redirectUri,
      'state' => $state
    );

    $url = self::API_AUTHORIZE . '?' . http_build_query($request);

    // a code has been returnd successfully
    if ($this->page->template->name === 'admin' && $this->input->get->code) {
      $this->getAccessToken();
    }

    return sprintf('<a href="%s" title="%s">%s</a>', $url, 'authorize', 'Authorize!');
  }

  /*
   * 2. GitHub redirects back to your site
   * Request the access_token
   *
   * Now you need to exchange the code for an access token.
   * You simply have to POST this code,
   * along with some app identification parameters.
   */
  public function getAccessToken() {
    $connection = new WireHttp;
    $connection->setHeader('Accept', 'application/json');

    $request = array(
      'client_id' => $this->clientId,
      'client_secret' => $this->clientSecret,
      'code' => $this->input->get->code,
      'redirect_uri' => $this->redirectUri,
      'state' => $this->input->state
    );

    $data = $connection->post(self::API_ACCESS_TOKEN, $request);

    if ($data) {
      $result = json_decode($data, true);

      if (isset($result['access_token'])) {
        $data = $this->modules->getModuleConfigData($this->className());
        $data['accessToken'] = $result['access_token'];
        $this->modules->saveModuleConfigData($this->className(), $data);
      } else {
        $error = "[GithubConnect]: No access token could be received.";
        if (isset($result['error'])) $error .= " Reason: `{$result['error']}` â€“ {$result['error_description']}";

        $this->log->save('errors', $error);
        $this->error($error);
      }

      $this->session->redirect($this->redirectUri);
    }
  }

}
